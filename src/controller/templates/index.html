<!DOCTYPE html>
<html>
<head>
    <title>Habitat Controller</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <link rel="icon" type="image/x-icon" href="/static/uofe_logo.png">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script> <!--Import socketio, used for websocket communication i.e. updates pushed from controller-->
    <script src="{{ url_for('static', filename='js/header.js') }}"></script> <!--Import header.js, used for the header of the page-->
    <script src="{{ url_for('static', filename='js/module-item.js') }}"></script> <!--Import module-item.js, used for the module list-->
</head>
<body>
    <main-header></main-header>
    
    <div class="dashboard-container">
        <div class="dashboard-card">
            <div id="camera_streams_container">
                <div class="streams-header">
                    <h1>&#128161; Live Streams</h1>
                    <div class="stream-controls">
                        <button id="show-all-streams" class="stream-control-btn" onclick="showAllStreams()">
                            Show All
                        </button>
                        <button id="hide-all-streams" class="stream-control-btn" onclick="hideAllStreams()">
                            Hide All
                        </button>
                    </div>
                </div>
                <div id="stream-cards">
                    <!-- Dynamic stream cards will be generated here -->
                </div>
            </div>
        </div>
        <div class="dashboard-card">
            <div id="module-list">
                <h2>Connected Modules</h2>
                <div id="modules"></div>
            </div>
        </div>
        <div class="dashboard-card">
            <div id="quick-commands">
                <h2>Quick Commands</h2>
                <div id="experiment-name-section">
                    <label for="experiment-name">Experiment Name (no spaces):</label>
                    <input type="text" id="experiment-name" placeholder="Enter experiment name" pattern="[^\s]+" title="No spaces allowed">
                </div>
                <div id="quick-commands-content">
                    <!-- Command buttons will be generated here -->
                </div>
            </div>
        </div>
        <div class="dashboard-card">
            <div id="module-status">
                <h2>Module Status</h2>
                <div id="status-content"></div>
            </div>
        </div>
        <div class="dashboard-card">
            <div id="recordings-link">
                <h2>Recordings</h2>
                <p>View and manage recordings from all modules.</p>
                <a href="/recordings" class="recordings-link-btn">View Recordings</a>
            </div>
        </div>
    </div>

    <!-- Module Selection Dialog -->
    <div id="module-selection-dialog" class="dialog" style="display: none;">
        <div class="dialog-content">
            <h3>Select Module</h3>
            <div class="dialog-options">
                <button class="dialog-option" data-module="all">All Modules</button>
                <div id="module-options"></div>
            </div>
            <button class="dialog-close">Cancel</button>
        </div>
    </div>

    <!-- Follow-up Questions Dialog -->
    <div id="followup-dialog" class="dialog" style="display: none;">
        <div class="dialog-content">
            <h3 id="followup-title">Additional Parameters</h3>
            <div id="followup-content">
                <!-- Dynamic content will be generated here -->
            </div>
            <div class="dialog-buttons">
                <button id="followup-confirm" class="dialog-confirm">Confirm</button>
                <button id="followup-cancel" class="dialog-cancel">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Fullscreen Stream Modal -->
    <div id="fullscreen-modal" class="fullscreen-modal" style="display: none;">
        <div class="fullscreen-content">
            <div class="fullscreen-header">
                <h2 id="fullscreen-title">Camera Stream</h2>
                <button class="fullscreen-close" onclick="closeFullscreen()">âœ•</button>
            </div>
            <div class="fullscreen-stream">
                <img id="fullscreen-video" src="" alt="Fullscreen Stream">
            </div>
        </div>
    </div>

    <script>
        // Command configuration
        const commands = {
            start_recording: {
                label: 'Start Recording',
                type: 'start_recording',
                description: 'Start recording on selected modules',
                needsFollowup: true,
                // Expected response: {status: 200, filename: "rec/{experiment_name}_{timestamp}.mp4", is_recording: true, message: "Recording started successfully"}
                followupQuestions: [
                    {
                        id: 'experiment_name',
                        label: 'Experiment Name',
                        type: 'text',
                        placeholder: 'Enter experiment name (no spaces)',
                        required: true,
                        validation: (value) => {
                            if (!value.trim()) return 'Experiment name is required';
                            if (value.includes(' ')) return 'No spaces allowed in experiment name';
                            return null;
                        }
                    },
                    {
                        id: 'duration',
                        label: 'Recording Duration (minutes)',
                        type: 'number',
                        placeholder: 'Leave empty for unlimited',
                        required: false,
                        min: 1,
                        max: 1440
                    }
                ]
            },
            stop_recording: {
                label: 'Stop Recording',
                type: 'stop_recording',
                description: 'Stop recording on selected modules',
                needsFollowup: false
                // Expected response: {status: 200, filename: "rec/{experiment_name}_{timestamp}.mp4", is_recording: false, message: "Recording stopped successfully", duration: 125.5, frames: 3765, filesize: 82.7mb}
            },
            get_status: {
                label: 'Get Status',
                type: 'get_status',
                description: 'Get the current status of selected modules',
                needsFollowup: false
                // Expected response: {status: 200, is_recording: false, is_streaming: false, cpu_temp: 45.2, cpu_usage: 12.5, memory_usage: 34.2, disk_space: 67.8, uptime: 3600}
            },
            list_recordings: {
                label: 'List Recordings',
                type: 'list_recordings',
                description: 'List available recordings on selected modules',
                needsFollowup: false
                // Expected response: {status: 200, recordings: [{filename: "rec/exp1_060127698.mp4", size: 1024000, created: "2024-01-15T10:30:00Z", duration: 125.5}]}
            },
            export_recordings: {
                label: 'Export Recordings',
                type: 'export_recordings',
                description: 'Export recordings from selected modules',
                needsFollowup: true,
                // Expected response: {status: 200, exported_files: ["{destination}/path/to/exported/file.mp4"], message: "Export completed successfully"}
                followupQuestions: [
                    {
                        id: 'destination',
                        label: 'Export Destination',
                        type: 'select',
                        options: [
                            { value: 'nas', label: 'NAS Storage' },
                            { value: 'controller', label: 'Controller Storage' }
                        ],
                        required: true
                    }
                ]
            },
            clear_recordings: {
                label: 'Clear Recordings',
                type: 'clear_recordings',
                description: 'Clear all recordings on selected modules',
                needsFollowup: true,
                // Expected response: {status: 200, deleted_count: 5, message: "5 recordings deleted successfully"}
                followupQuestions: [
                    {
                        id: 'confirmation',
                        label: 'Are you sure you want to delete ALL recordings on the module?',
                        type: 'confirmation',
                        message: 'This action cannot be undone. All recordings on the selected modules will be permanently deleted.',
                        required: true
                    }
                ]
            },
            start_streaming: {
                label: 'Start Streaming',
                type: 'start_streaming',
                description: 'Start streaming on selected modules - CAMERA ONLY',
                needsFollowup: true,
                // Expected response: {status: 200, stream_url: "http://{module_ip}:8080/video_feed", is_streaming: true, message: "Streaming started successfully"}
                followupQuestions: [
                    {
                        id: 'stream_port',
                        label: 'Stream Port',
                        type: 'number',
                        placeholder: '8080',
                        default: 8080,
                        required: true,
                        min: 1024,
                        max: 65535
                    },
                    {
                        id: 'stream_quality',
                        label: 'Stream Quality',
                        type: 'select',
                        options: [
                            { value: 'low', label: 'Low (480p)' },
                            { value: 'medium', label: 'Medium (720p)' },
                            { value: 'high', label: 'High (1080p)' }
                        ],
                        default: 'medium',
                        required: true
                    }
                ]
            },
            stop_streaming: {
                label: 'Stop Streaming',
                type: 'stop_streaming',
                description: 'Stop streaming on selected modules - CAMERA ONLY',
                needsFollowup: false
                // Expected response: {status: 200, is_streaming: false, message: "Streaming stopped successfully"}
            },
        };

        // Generate command buttons
        function generateCommandButtons() {
            const container = document.getElementById('quick-commands-content');
            container.innerHTML = ''; // Clear existing buttons

            Object.entries(commands).forEach(([id, command]) => {
                const button = document.createElement('button');
                button.id = id;
                
                // Special styling for start/stop recording buttons
                if (id === 'start_recording') {
                    button.className = 'command-button start-recording-btn';
                } else if (id === 'stop_recording') {
                    button.className = 'command-button stop-recording-btn';
                } else {
                    button.className = 'command-button';
                }
                
                button.textContent = command.label;
                button.title = command.description;
                
                button.addEventListener('click', () => {
                    currentCommand = command.type;
                    dialog.style.display = 'flex';
                });
                
                container.appendChild(button);
            });
        }

        console.log('Script starting...'); // Initial script load

        var socket = io(); // The socket object receives updates from the controller
        let isInitialLoad = true; // Flag to track initial page load
        
        // WebSocket event handlers
        socket.on('connect', function() { // When connection is established, log it
            console.log('WebSocket connection established');
            socket.emit('module_update'); // Request initial module data
        });
    
        socket.on('disconnect', function() { // When connection is closed, log it
            console.log('WebSocket connection closed');
        });
        
        socket.on('module_update', function(data) { // When module update is received, log it and update the module list
            console.log('Received module update:', data);
            updateModuleList(data.modules);
            updateDashboardOverview(data.modules);
            
            // Show all streams only on initial page load
            if (isInitialLoad && data.modules && data.modules.length > 0) {
                // Small delay to ensure DOM elements are created
                setTimeout(() => {
                    showAllStreams();
                }, 100);
                isInitialLoad = false; // Mark initial load as complete
            }
        });
        
        socket.on('ptp_status', function(data) { // When PTP status is received, log it and update the PTP chart
            console.log('Received PTP update:', data);
            updatePTPChart(data);
        });
        
        socket.on('error', function(error) { // When an error occurs, log it
            console.error('WebSocket error:', error);
        });

        socket.on('module_status', function(data) {
            console.log('Received module status:', data);
            displayModuleStatus(data);
        });

        socket.on('client_ip', function(ip) {
            clientIP = ip;
            console.log('Received client IP:', ip);
        });

        function displayModuleStatus(data) {
            const statusContent = document.getElementById('status-content');
            const timestamp = new Date(data.status.timestamp * 1000).toLocaleString();
            
            console.log('=== STATUS UPDATE ===');
            console.log('Module ID:', data.module_id);
            console.log('Status data:', data.status);
            console.log('Status content element:', statusContent);
            
            // Create or update the status card for this module
            let statusCard = document.getElementById(`status-card-${data.module_id}`);
            console.log('Existing status card:', statusCard);
            
            if (!statusCard) {
                statusCard = document.createElement('div');
                statusCard.id = `status-card-${data.module_id}`;
                statusCard.className = 'status-card';
                statusContent.appendChild(statusCard);
                console.log('Created new status card for module:', data.module_id);
            } else {
                console.log('Updating existing status card for module:', data.module_id);
            }
            
            // Log all existing status cards
            const allStatusCards = statusContent.querySelectorAll('.status-card');
            console.log('Total status cards in DOM:', allStatusCards.length);
            allStatusCards.forEach((card, index) => {
                console.log(`Status card ${index}:`, card.id);
            });
            
            const statusHTML = `
                <div class="status-header">
                    <h3>${data.module_id}</h3>
                    <span class="status-timestamp">${timestamp}</span>
                </div>
                <div class="status-grid">
                    <div class="status-item">
                        <span class="status-label">CPU Temperature</span>
                        <span class="status-value">${data.status.cpu_temp}Â°C</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">CPU Usage</span>
                        <span class="status-value">${data.status.cpu_usage}%</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">Memory Usage</span>
                        <span class="status-value">${data.status.memory_usage}%</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">Uptime</span>
                        <span class="status-value">${formatUptime(data.status.uptime)}</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">Disk Space</span>
                        <span class="status-value">${data.status.disk_space}%</span>
                    </div>
                    ${data.status.ptp4l_offset !== null ? `
                        <div class="status-item">
                            <span class="status-label">PTP4L Offset</span>
                            <span class="status-value">${data.status.ptp4l_offset}ns</span>
                        </div>
                    ` : ''}
                    ${data.status.ptp4l_freq !== null ? `
                        <div class="status-item">
                            <span class="status-label">PTP4L Frequency</span>
                            <span class="status-value">${data.status.ptp4l_freq}ppb</span>
                        </div>
                    ` : ''}
                    ${data.status.phc2sys_offset !== null ? `
                        <div class="status-item">
                            <span class="status-label">PHC2SYS Offset</span>
                            <span class="status-value">${data.status.phc2sys_offset}ns</span>
                        </div>
                    ` : ''}
                    ${data.status.phc2sys_freq !== null ? `
                        <div class="status-item">
                            <span class="status-label">PHC2SYS Frequency</span>
                            <span class="status-value">${data.status.phc2sys_freq}ppb</span>
                        </div>
                    ` : ''}
                    ${data.status.recording !== undefined ? `
                        <div class="status-item">
                            <span class="status-label">Recording</span>
                            <span class="status-value">${data.status.recording_status ? 'Yes' : 'No'}</span>
                        </div>
                    ` : ''}
                    ${data.status.streaming !== undefined ? `
                        <div class="status-item">
                            <span class="status-label">Streaming</span>
                            <span class="status-value">${data.status.streaming_status ? 'Yes' : 'No'}</span>
                        </div>
                    ` : ''}
                </div>
            `;
            
            statusCard.innerHTML = statusHTML;
            console.log('Updated status card for module:', data.module_id);
            console.log('=== END STATUS UPDATE ===');
            
            // Update recording indicator in module list
            if (data.status.recording !== undefined) {
                updateRecordingIndicator(data.module_id, data.status.recording);
            }
        }

        function formatUptime(seconds) {
            if (seconds === 0) return '0s';
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            
            const parts = [];
            if (hours > 0) parts.push(`${hours}h`);
            if (minutes > 0) parts.push(`${minutes}m`);
            if (remainingSeconds > 0) parts.push(`${remainingSeconds}s`);
            
            return parts.join(' ');
        }

        // Module selection dialog
        const dialog = document.getElementById('module-selection-dialog');
        const moduleOptions = document.getElementById('module-options');
        const closeButton = document.querySelector('.dialog-close');
        let currentCommand = null;
        let selectedModuleId = null;

        // Follow-up dialog elements
        const followupDialog = document.getElementById('followup-dialog');
        const followupTitle = document.getElementById('followup-title');
        const followupContent = document.getElementById('followup-content');
        const followupConfirm = document.getElementById('followup-confirm');
        const followupCancel = document.getElementById('followup-cancel');

        // Command Button Event Listeners
        closeButton.addEventListener('click', () => {
            dialog.style.display = 'none';
            currentCommand = null;
            selectedModuleId = null;
        });

        // Follow-up dialog event listeners
        followupCancel.addEventListener('click', () => {
            followupDialog.style.display = 'none';
            currentCommand = null;
            selectedModuleId = null;
        });

        followupConfirm.addEventListener('click', () => {
            const formData = collectFollowupData();
            if (formData) {
                sendCommandWithParams(selectedModuleId, formData);
                followupDialog.style.display = 'none';
            }
        });

        // Generate follow-up form
        function generateFollowupForm(commandType) {
            const command = commands[commandType];
            if (!command || !command.needsFollowup) return '';

            followupTitle.textContent = `Configure ${command.label}`;
            let formHTML = '';

            command.followupQuestions.forEach(question => {
                formHTML += `<div class="form-group">`;
                formHTML += `<label for="${question.id}">${question.label}</label>`;

                // Check if this is the experiment name field and if there's already a value on the page
                let defaultValue = question.default || '';
                if (question.id === 'experiment_name') {
                    const existingExperimentName = document.getElementById('experiment-name');
                    if (existingExperimentName && existingExperimentName.value.trim()) {
                        defaultValue = existingExperimentName.value.trim();
                    }
                }

                switch (question.type) {
                    case 'text':
                        formHTML += `<input type="text" id="${question.id}" placeholder="${question.placeholder || ''}" value="${defaultValue}" ${question.required ? 'required' : ''}>`;
                        break;
                    case 'number':
                        formHTML += `<input type="number" id="${question.id}" placeholder="${question.placeholder || ''}" min="${question.min || ''}" max="${question.max || ''}" value="${defaultValue}" ${question.required ? 'required' : ''}>`;
                        break;
                    case 'select':
                        formHTML += `<select id="${question.id}" ${question.required ? 'required' : ''}>`;
                        question.options.forEach(option => {
                            const selected = option.value === defaultValue ? 'selected' : '';
                            formHTML += `<option value="${option.value}" ${selected}>${option.label}</option>`;
                        });
                        formHTML += `</select>`;
                        break;
                    case 'checkbox':
                        const checked = defaultValue ? 'checked' : '';
                        formHTML += `<input type="checkbox" id="${question.id}" ${checked}>`;
                        break;
                    case 'confirmation':
                        formHTML += `<div class="confirmation-message">${question.message}</div>`;
                        formHTML += `<input type="checkbox" id="${question.id}" ${question.required ? 'required' : ''}> I understand and want to proceed`;
                        break;
                }

                formHTML += `</div>`;
            });

            return formHTML;
        }

        // Collect data from follow-up form
        function collectFollowupData() {
            const command = commands[currentCommand];
            if (!command || !command.needsFollowup) return {};

            const formData = {};
            let isValid = true;

            command.followupQuestions.forEach(question => {
                const element = document.getElementById(question.id);
                if (!element) return;

                let value;
                switch (question.type) {
                    case 'text':
                    case 'number':
                        value = element.value.trim();
                        break;
                    case 'select':
                        value = element.value;
                        break;
                    case 'checkbox':
                        value = element.checked;
                        break;
                    case 'confirmation':
                        value = element.checked;
                        break;
                }

                // Validation
                if (question.required && (value === '' || value === false || value === null)) {
                    showError(`${question.label} is required`);
                    isValid = false;
                    return;
                }

                if (question.validation && value !== '') {
                    const error = question.validation(value);
                    if (error) {
                        showError(error);
                        isValid = false;
                        return;
                    }
                }

                formData[question.id] = value;
            });

            return isValid ? formData : null;
        }

        // Show error message
        function showError(message) {
            alert(message); // You could replace this with a better error display
        }

        // Send command with parameters
        function sendCommandWithParams(moduleId, params) {
            const command = {
                type: currentCommand,
                module_id: moduleId,
                params: params
            };

            console.log('Sending command with params:', command);
            socket.emit('command', command);
            currentCommand = null;
            selectedModuleId = null;
        }

        // Update the module selection dialog options
        function updateModuleOptions(modules) {
            moduleOptions.innerHTML = '';
            modules.forEach(module => {
                const button = document.createElement('button');
                button.className = 'dialog-option';
                button.textContent = `${module.type} (${module.id})`;
                button.dataset.moduleId = module.id;
                button.addEventListener('click', () => {
                    selectedModuleId = module.id;
                    handleModuleSelection();
                });
                moduleOptions.appendChild(button);
            });
        }

        // Handle module selection
        function handleModuleSelection() {
            dialog.style.display = 'none';
            
            const command = commands[currentCommand];
            if (command && command.needsFollowup) {
                // Show follow-up dialog
                followupContent.innerHTML = generateFollowupForm(currentCommand);
                followupDialog.style.display = 'flex';
            } else {
                // Send command immediately
                sendCommandWithParams(selectedModuleId, {});
            }
        }

        // Send command to module (legacy function - now uses sendCommandWithParams)
        function sendCommand(moduleId) {
            if (!currentCommand) {
                console.error('No command selected');
                return;
            }

            const command = {
                type: currentCommand,
                module_id: moduleId,
                params: {}  // Initialize empty params object
            };

            // Add parameters for streaming commands
            if (currentCommand === 'start_streaming') {
                if (!clientIP) {
                    alert('Client IP not available. Please refresh the page and try again.');
                    return;
                }
                command.params = {
                    client_ip: clientIP,
                    port: 8080  // Default port
                };
            }

            // Add experiment name for start_recording command
            if (currentCommand === 'start_recording') {
                const experimentNameInput = document.getElementById('experiment-name');
                const experimentName = experimentNameInput.value.trim();
                
                if (!experimentName) {
                    alert('Please enter an experiment name before starting recording.');
                    return;
                }
                
                if (experimentName.includes(' ')) {
                    alert('Experiment name cannot contain spaces. Please use underscores or hyphens instead.');
                    return;
                }
                
                command.params = {
                    experiment_name: experimentName
                };
            }

            console.log('Sending command:', command);
            socket.emit('command', command);
            currentCommand = null;
        }

        // Add click handler for "All Modules" option
        document.querySelector('[data-module="all"]').addEventListener('click', () => {
            selectedModuleId = 'all';
            handleModuleSelection();
        });

        // Update the module list
        let availableModules = [];  // Store modules globally

        function updateModuleList(modules) {
            console.log('updateModuleList called with:', modules);
            const moduleList = document.getElementById('modules');
            
            if (!moduleList) {
                console.error('Could not find modules element');
                return;
            }
            
            // Store modules globally
            availableModules = modules;
            
            // Update stream cards for camera modules
            updateStreamCards(modules);
            
            moduleList.innerHTML = '';
            
            if (!modules || modules.length === 0) {
                console.log('No modules to display');
                moduleList.innerHTML = '<p>No modules found</p>';
                return;
            }
            
            // Get list of active module IDs for cleanup
            const activeModuleIds = modules.map(module => module.id);
            
            modules.forEach(module => {
                console.log('Creating module element for:', module);
                const moduleElement = document.createElement('module-item');
                moduleElement.setAttribute('module-id', module.id);
                moduleElement.setAttribute('module-type', module.type);
                moduleElement.setAttribute('module-ip', module.ip);
                moduleElement.setAttribute('recording', module.recording || false);
                moduleList.appendChild(moduleElement);
            });

            // Update the module selection dialog options
            updateModuleOptions(modules);
            
            // Clean up status cards for disconnected modules
            cleanupDisconnectedModules(activeModuleIds);
        }

        // Function to update recording indicators
        function updateRecordingIndicator(moduleId, isRecording) {
            const moduleElement = document.querySelector(`module-item[module-id="${moduleId}"]`);
            if (moduleElement) {
                moduleElement.setAttribute('recording', isRecording);
            }
        }

        // Function to update stream cards for camera modules
        function updateStreamCards(modules) {
            const streamCardsContainer = document.getElementById('stream-cards');
            if (!streamCardsContainer) {
                console.error('Could not find stream-cards element');
                return;
            }

            // Clear existing stream cards
            streamCardsContainer.innerHTML = '';

            // Filter for camera modules only
            const cameraModules = modules.filter(module => module.type === 'camera');
            
            if (cameraModules.length === 0) {
                streamCardsContainer.innerHTML = '<p>No camera modules connected</p>';
                return;
            }

            // Create a stream card for each camera module
            cameraModules.forEach(module => {
                const streamCard = createStreamCard(module);
                streamCardsContainer.appendChild(streamCard);
            });
        }

        // Function to create a stream card for a camera module
        function createStreamCard(module) {
            const card = document.createElement('div');
            card.className = 'stream-card';
            card.id = `stream-card-${module.id}`;
            
            card.innerHTML = `
                <div class="stream-card-header">
                    <h3>${module.id}</h3>
                    <span class="stream-ip">${module.ip}</span>
                </div>
                <div class="stream-content">
                    <div class="stream-placeholder" id="placeholder-${module.id}">
                        <div class="placeholder-content">
                            <span class="placeholder-icon">&#128247;</span>
                            <p>Camera Stream</p>
                            <button class="show-stream-btn" onclick="showStream('${module.id}', '${module.ip}')">
                                Show Stream
                            </button>
                        </div>
                    </div>
                    <div class="stream-video" id="video-${module.id}" style="display: none;">
                        <img src="http://${module.ip}:8080/video_feed" 
                             width="640" height="480" 
                             onerror="handleStreamError('${module.id}')"
                             onload="handleStreamLoad('${module.id}')">
                        <div class="stream-controls">
                            <button class="hide-stream-btn" onclick="hideStream('${module.id}')">
                                Hide Stream
                            </button>
                            <button class="fullscreen-btn" onclick="openFullscreen('${module.id}', '${module.ip}')" title="Fullscreen">
                                â›¶
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            return card;
        }

        // Function to show stream for a specific module
        function showStream(moduleId, moduleIp) {
            const placeholder = document.getElementById(`placeholder-${moduleId}`);
            const videoContainer = document.getElementById(`video-${moduleId}`);
            
            if (placeholder && videoContainer) {
                placeholder.style.display = 'none';
                videoContainer.style.display = 'block';
                
                // Get the image element and set up proper handlers
                const img = videoContainer.querySelector('img');
                if (img) {
                    // Set up error and load handlers
                    img.onerror = () => handleStreamError(moduleId);
                    img.onload = () => handleStreamLoad(moduleId);
                    
                    // Set the source to trigger loading
                    img.src = `http://${moduleIp}:8080/video_feed`;
                }
            }
        }

        // Function to hide stream for a specific module
        function hideStream(moduleId) {
            const placeholder = document.getElementById(`placeholder-${moduleId}`);
            const videoContainer = document.getElementById(`video-${moduleId}`);
            
            if (placeholder && videoContainer) {
                // Clear the image source and remove error handlers before hiding
                const img = videoContainer.querySelector('img');
                if (img) {
                    // Remove error handler to prevent alerts
                    img.onerror = null;
                    img.onload = null;
                    // Clear the source
                    img.src = '';
                }
                
                placeholder.style.display = 'block';
                videoContainer.style.display = 'none';
            }
        }

        // Function to handle stream load success
        function handleStreamLoad(moduleId) {
            console.log(`Stream loaded successfully for module: ${moduleId}`);
        }

        // Function to handle stream error
        function handleStreamError(moduleId) {
            console.error(`Error loading stream for module: ${moduleId}`);
            // Only show alert if the stream is currently visible (not being hidden)
            const videoContainer = document.getElementById(`video-${moduleId}`);
            if (videoContainer && videoContainer.style.display !== 'none') {
                alert(`Failed to connect to camera ${moduleId}. Please check if the camera is running and accessible.`);
                hideStream(moduleId);
            }
        }

        // Function to show all streams
        function showAllStreams() {
            if (!availableModules) return;
            
            const cameraModules = availableModules.filter(module => module.type === 'camera');
            cameraModules.forEach(module => {
                showStream(module.id, module.ip);
            });
            
            console.log(`Showing all ${cameraModules.length} camera streams`);
        }

        // Function to hide all streams
        function hideAllStreams() {
            if (!availableModules) return;
            
            const cameraModules = availableModules.filter(module => module.type === 'camera');
            cameraModules.forEach(module => {
                hideStream(module.id);
            });
            
            console.log(`Hiding all ${cameraModules.length} camera streams`);
        }

        // Function to open fullscreen stream
        function openFullscreen(moduleId, moduleIp) {
            const modal = document.getElementById('fullscreen-modal');
            const title = document.getElementById('fullscreen-title');
            const video = document.getElementById('fullscreen-video');
            
            if (modal && title && video) {
                title.textContent = `${moduleId} - Fullscreen`;
                video.src = `http://${moduleIp}:8080/video_feed`;
                modal.style.display = 'flex';
                
                // Prevent body scroll when modal is open
                document.body.style.overflow = 'hidden';
            }
        }

        // Function to close fullscreen stream
        function closeFullscreen() {
            const modal = document.getElementById('fullscreen-modal');
            const video = document.getElementById('fullscreen-video');
            
            if (modal && video) {
                // Clear the video source to stop the stream
                video.src = '';
                modal.style.display = 'none';
                
                // Restore body scroll
                document.body.style.overflow = 'auto';
            }
        }

        // Close fullscreen modal when clicking outside the content
        document.addEventListener('click', function(event) {
            const modal = document.getElementById('fullscreen-modal');
            const content = document.querySelector('.fullscreen-content');
            
            if (modal && modal.style.display === 'flex' && event.target === modal) {
                closeFullscreen();
            }
        });

        // Close fullscreen modal with Escape key
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                const modal = document.getElementById('fullscreen-modal');
                if (modal && modal.style.display === 'flex') {
                    closeFullscreen();
                }
            }
        });

        // Add cleanup for disconnected modules
        function cleanupDisconnectedModules(activeModules) {
            const statusContent = document.getElementById('status-content');
            const statusCards = statusContent.getElementsByClassName('status-card');
            
            // Convert HTMLCollection to Array for easier manipulation
            Array.from(statusCards).forEach(card => {
                const moduleId = card.id.replace('status-card-', '');
                if (!activeModules.includes(moduleId)) {
                    card.remove();
                }
            });
        }

        // Update the dashboard overview
        function updateDashboardOverview(modules) {
            console.log('updateDashboardOverview called with:', modules);
            const numberOfModules = document.getElementById('number-of-modules');
            if (!numberOfModules) {
                console.error('Could not find number-of-modules element');
                return;
            }
            numberOfModules.textContent = modules ? modules.length : 0;

            // Debug logging for module types
            if (modules) {
                console.log('All module types:', modules.map(m => m.type));
                console.log('Camera modules:', modules.filter(module => module.type === 'camera'));
                console.log('TTL modules:', modules.filter(module => module.type === 'ttl'));
            }

            const numberOfCameraModules = document.getElementById('number-of-camera-modules');
            if (!numberOfCameraModules) {
                console.error('Could not find number-of-camera-modules element');
                return;
            }
            numberOfCameraModules.textContent = modules ? modules.filter(module => module.type === 'camera').length : 0; // Update the number of camera modules in the dashboard overview
            const numberOfTTLModules = document.getElementById('number-of-ttl-modules');  
            if (!numberOfTTLModules) {
                console.error('Could not find number-of-ttl-modules element');
                return;
            }
            numberOfTTLModules.textContent = modules ? modules.filter(module => module.type === 'ttl').length : 0; // Update the number of TTL modules in the dashboard overview
        }   

        function updatePTPChart(data) {
            console.log('PTP data:', data);
            // TODO: Implement PTP chart 
        }

        // Handle recordings list response
        socket.on('recordings_list', function(data) {
            // Handle module recordings
            const moduleRecordingsList = document.querySelector('#module-recordings .recordings-list');
            if (moduleRecordingsList) {
                moduleRecordingsList.innerHTML = '';
                
                if (!data.module_recordings || data.module_recordings.length === 0) {
                    moduleRecordingsList.innerHTML = '<p>No recordings found</p>';
                } else {
                    const recordingsHTML = data.module_recordings.map(recording => `
                        <div class="recording-item">
                            <div class="recording-info">
                                <span class="recording-name">${recording.filename}</span>
                                <span class="recording-date">${recording.created}</span>
                                <span class="recording-size">${formatFileSize(recording.size)}</span>
                            </div>
                            <div class="recording-actions">
                                <button class="action-button export" title="Export Recording" data-filename="${recording.filename}">
                                    Export
                                </button>
                                <button class="action-button delete" title="Delete Recording" data-filename="${recording.filename}">
                                    Delete
                                </button>
                            </div>
                        </div>
                    `).join('');
                    moduleRecordingsList.innerHTML = recordingsHTML;
                }
            }

            // Handle exported recordings
            const exportedRecordingsList = document.querySelector('#exported-recordings .recordings-list');
            if (exportedRecordingsList) {
                exportedRecordingsList.innerHTML = '';
                
                if (!data.exported_recordings || data.exported_recordings.length === 0) {
                    exportedRecordingsList.innerHTML = '<p>No exported recordings found</p>';
                } else {
                    const recordingsHTML = data.exported_recordings.map(recording => `
                        <div class="recording-item">
                            <div class="recording-info">
                                <span class="recording-name">${recording.filename}</span>
                                <span class="recording-date">${recording.created}</span>
                                <span class="recording-size">${formatFileSize(recording.size)}</span>
                            </div>
                            <div class="recording-actions">
                                <button class="action-button delete" title="Delete Recording" data-filename="${recording.filename}">
                                    Delete
                                </button>
                            </div>
                        </div>
                    `).join('');
                    exportedRecordingsList.innerHTML = recordingsHTML;
                }
            }

            // Add event listeners for the action buttons
            moduleRecordingsList.querySelectorAll('.action-button.export').forEach(button => {
                button.addEventListener('click', () => {
                    const filename = button.dataset.filename;
                    socket.emit('command', {
                        type: 'export_recordings',
                        module_id: 'all',
                        filename: filename
                    });
                });
            });

            moduleRecordingsList.querySelectorAll('.action-button.delete').forEach(button => {
                button.addEventListener('click', () => {
                    const filename = button.dataset.filename;
                    if (confirm(`Are you sure you want to delete ${filename}?`)) {
                        socket.emit('command', {
                            type: 'clear_recordings',
                            module_id: 'all',
                            filename: filename
                        });
                    }
                });
            });

            exportedRecordingsList.querySelectorAll('.action-button.delete').forEach(button => {
                button.addEventListener('click', () => {
                    const filename = button.dataset.filename;
                    if (confirm(`Are you sure you want to delete ${filename}?`)) {
                        // TODO: Implement delete for exported recordings
                        alert('Deleting exported recordings is not yet implemented');
                    }
                });
            });
        });

        // Handle export complete response
        socket.on('export_complete', function(data) {
            if (data.success) {
                // Refresh the recordings list
                socket.emit('module_update');
            } else {
                alert(`Export failed: ${data.error || 'Unknown error'}`);
            }
        });

        // Helper function to format file size
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // Tab switching functionality
        document.querySelectorAll('.tab-button').forEach(button => {
            button.addEventListener('click', () => {
                // Remove active class from all buttons and contents
                document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
                document.querySelectorAll('.recordings-content').forEach(content => content.classList.remove('active'));
                
                // Add active class to clicked button and corresponding content
                button.classList.add('active');
                const tabId = button.dataset.tab;
                document.getElementById(tabId).classList.add('active');
            });
        });

        // Initialize command buttons
        generateCommandButtons();

        // Log when the page is fully loaded
        window.addEventListener('load', function() {
            console.log('Page fully loaded');
        });
    </script>
</body>
</html> 
