<!DOCTYPE html>
<html>
<head>
    <title>Settings - SAVIOUR</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <link rel="icon" href="{{ url_for('static', filename='uofe_logo_alpha.png') }}">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script> <!--Import socketio, used for websocket communication i.e. updates pushed from controller-->
    <script src="{{ url_for('static', filename='js/header.js') }}"></script> <!--Import header.js, used for the header of the page-->
</head>
<body>
    <main-header></main-header>

    <div class="dashboard-container">
        <div class="dashboard-card module-config-card">
            <div class="module-config-header">
                <h2>Module Configurations</h2>
                <div class="header-buttons">
                    <button id="refresh-configs-btn" onclick="getModuleConfigs()" class="refresh-btn">
                        <span class="refresh-icon">üîÑ</span> Refresh Configs
                    </button>

                </div>
            </div>
            <div class="module-config-layout">
                <div class="module-config-panel">
                <div id="module-configs-content">
                    <!--Module configs will be displayed here-->
                        <p class="no-configs-message">No module configurations available. Click "Refresh Configs" to request them.</p>
                    </div>
                </div>
                <div class="settings-sidebar">
                    <div class="livestream-panel">
                        <div class="livestream-header">
                            <h3>Live Preview</h3>
                            <span class="livestream-status">‚óè Live</span>
                        </div>
                        <div class="livestream-container">
                            <div id="livestream-placeholder">
                                <p>Camera stream will appear here when a camera module is detected</p>
                            </div>
                            <img id="livestream-video" src="" alt="Livestream from camera"    
                            class="livestream-video" style="display: none;"> <!-- 16:9 aspect ratio to match 2304x1296 camera -->
                        </div>
                    </div>
                    <div class="settings-actions-panel">
                        <div class="settings-actions-header">
                            <h3>Configuration Actions</h3>
                        </div>
                        <div class="settings-actions-content">
                            <button id="save-all-configs-btn" class="save-all-button">
                                üíæ Save All Changes
                            </button>
                            <button id="reset-all-configs-btn" class="reset-all-button">
                                üîÑ Reset All
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <!-- <div class="dashboard-card">
            <div id="settings">
                <div id="settings-top-bar">
                    <h2>Settings</h2>
                    <button id="refresh-settings-button">&#128260 Refresh</button>
                </div>
                <form id="settings-form">
                    <div id="settings-content"> -->
                    <!--Generate settings content based on the returned config file.-->
                    <!-- </div>
                    <div id="settings-actions">
                        <button type="submit" id="save-settings-button" class="save-button">üíæ Save Changes</button>
                        <button type="button" id="reset-settings-button" class="reset-button">üîÑ Reset</button>
                    </div>
                </form>
            </div>
        </div> -->
    </div>

    <script>
        // ============================================================================
        // GLOBAL VARIABLES
        // ============================================================================
        
        // Initialize Socket.IO connection for real-time communication with the backend
        const socket = io();

        // Store the main settings object returned from the backend
        var settings = {}; 
        
        // Array to store settings in dot notation format (e.g., "camera.fps", "mask.coordinates")
        var settingsArray = []; 
        
        // Object to store parsed settings with their types and values
        var parsedSettings = {}; 
        
        // Track which sections are currently open
        let openSections = new Set();
        
        // ============================================================================
        // SOCKET.IO EVENT HANDLERS
        // ============================================================================
        
        // Handle successful connection to the server
        socket.on('connect', () => {
            console.log('Connected to server');
            // refreshSettings(); // Request the current config from the backend
            // console.log('Requested APA settings from backend');
            socket.emit('module_update'); // Request initial module data for livestream
            getModuleConfigs();
        });
        
        // Handle disconnection from the server
        socket.on('disconnect', () => {
            console.log('Disconnected from server');
        });

        // Handle receiving settings data from the backend
        // socket.on('send_settings_to_frontend', (data) => {
        //     settings = data;
        //     console.log('Received settings from backend: ', settings);
            
        //     // Clear previous settings data to prevent duplicates
        //     settingsArray = [];
        //     parsedSettings = {};
            
        //     // Extract settings in dot notation from the nested object structure
        //     findSettingsFromObject(settings); 
        //     console.log(settingsArray); // Log the extracted settings variables
        //     console.log(parsedSettings); // Log the settings with their types
        //     generateSettingsContent(); // Use received settings to create the settings form
        //     document.body.style.cursor="default"; // Reset cursor style
        // })
        
        // Handle module configuration updates from the backend
        socket.on('module_configs_update', (data) => {
            console.log('Module configs update:', data);
            displayModuleConfigs(data.module_configs);
        })

        // Handle streaming status updates from modules
        socket.on('streaming_started', (data) => {
            console.log('Streaming started:', data);
            refreshLivestream();
        })

        // Handle module updates from the backend
        socket.on('module_update', (data) => {
            console.log('Received module update:', data);
            updateLivestreamFromModules(data.modules || []);
        });

        // ============================================================================
        // LIVESTREAM MANAGEMENT FUNCTIONS
        // ============================================================================
        
        // Update livestream based on detected camera modules
        function updateLivestreamFromModules(modules) {
            console.log('updateLivestreamFromModules called with:', modules);
            
            // Find camera modules
            console.log('All modules:', modules);
            console.log('Module types found:', modules.map(m => m.type));
            const cameraModules = modules.filter(module => module.type === 'camera');
            console.log('Found camera modules:', cameraModules);
            
            // Set up livestream if camera module is found
            if (cameraModules.length > 0) {
                const cameraModule = cameraModules[0]; // Use the first camera module
                setupLivestream(cameraModule.ip);
            } else {
                // Hide livestream if no camera modules
                hideLivestream();
            }
        }
        
        // Set up livestream with camera module IP
        function setupLivestream(cameraIP) {
            console.log('Setting up livestream with camera IP:', cameraIP);
            const livestreamVideo = document.getElementById('livestream-video');
            const livestreamPlaceholder = document.getElementById('livestream-placeholder');
            
            if (livestreamVideo && livestreamPlaceholder) {
                // Set the video source to the camera module's IP
                livestreamVideo.src = `http://${cameraIP}:8080/video_feed`;
                livestreamVideo.style.display = 'block';
                livestreamPlaceholder.style.display = 'none';
                
                // Add error handling for the video stream
                livestreamVideo.onerror = function() {
                    console.error('Failed to load camera stream from:', cameraIP);
                    livestreamVideo.style.display = 'none';
                    livestreamPlaceholder.style.display = 'block';
                    livestreamPlaceholder.innerHTML = '<p>Failed to connect to camera stream</p>';
                };
                
                // Add success handler
                livestreamVideo.onload = function() {
                    console.log('Camera stream loaded successfully from:', cameraIP);
                };
            }
        }
        
        // Hide livestream when no camera modules are available
        function hideLivestream() {
            const livestreamVideo = document.getElementById('livestream-video');
            const livestreamPlaceholder = document.getElementById('livestream-placeholder');
            
            if (livestreamVideo && livestreamPlaceholder) {
                livestreamVideo.style.display = 'none';
                livestreamPlaceholder.style.display = 'block';
                livestreamPlaceholder.innerHTML = '<p>No camera modules detected</p>';
            }
        }

        // ============================================================================
        // SETTINGS MANAGEMENT FUNCTIONS
        // ============================================================================
        
        // Request fresh settings from the backend
        // function refreshSettings() {
        //     document.body.style.cursor="wait"; // Show loading cursor
        //     socket.emit('request_settings_from_backend');
        // }

        // Add click event listener to the refresh settings button
        // document.getElementById('refresh-settings-button').addEventListener('click', refreshSettings);

        // ============================================================================
        // SETTINGS FORM GENERATION
        // ============================================================================
        
        // Generate the main settings form content from the received settings data
        // function generateSettingsContent() {
        //     const container = document.getElementById("settings-content");
        //     // Clear previous content before generating new form
        //     container.innerHTML = "";
            
        //     // Group settings by their primary key (first part of dot notation)
        //     // This creates logical sections like "camera", "mask", "shock_zones"
        //     const groupedSettings = {};
        //     settingsArray.forEach(setting => {
        //         const parts = setting.split('.');
        //         const groupKey = parts[0];
        //         if (!groupedSettings[groupKey]) {
        //             groupedSettings[groupKey] = [];
        //         }
        //         groupedSettings[groupKey].push(setting);
        //     });
            
        //     // Create a flex container for responsive two-column layout
        //     const flexContainer = document.createElement("div");
        //     flexContainer.className = "settings-flex-container";
            
        //     // Generate content for each settings group
        //     Object.keys(groupedSettings).forEach(groupKey => {
        //         const groupDiv = document.createElement("div");
        //         groupDiv.className = "settings-group";
                
        //         // Add group header with formatted name
        //         const groupHeader = document.createElement("h3");
        //         groupHeader.className = "settings-group-header";
        //         groupHeader.textContent = formatGroupName(groupKey);
        //         groupDiv.appendChild(groupHeader);
                
        //         // Add individual settings inputs for this group
        //         groupedSettings[groupKey].forEach(setting => {
        //             const settingDiv = document.createElement("div");
        //             settingDiv.className = "settings-input-group";
                    
        //             // Create label for the setting
        //             const settingLabel = document.createElement("label");
        //             settingLabel.textContent = formatSettingName(setting);
        //             settingLabel.className = "settings-label";
        //             settingLabel.title = setting; // Show full path on hover for debugging
                    
        //             // Create input field for the setting
        //             const settingInput = document.createElement("input");
        //             settingInput.className = "settings-input";
        //             settingInput.name = setting; // Set name for form submission
        //             settingInput.value = parsedSettings[setting].value;
                    
        //             // Handle different input types based on the setting's data type
        //             if (parsedSettings[setting].type === "number") {
        //                 settingInput.type = "number";
        //                 settingInput.step = "0.00001"; // Allow decimal precision
        //                 settingInput.className += " settings-input-number";
        //             } else {
        //                 settingInput.type = "text";
        //                 settingInput.className += " settings-input-text";
        //             }
                    
        //             // Wrap input in a container for better styling
        //             const inputWrapper = document.createElement("div");
        //             inputWrapper.className = "settings-input-wrapper";
        //             inputWrapper.appendChild(settingInput);
                    
        //             // Assemble the setting group
        //             settingDiv.appendChild(settingLabel);
        //             settingDiv.appendChild(inputWrapper);
        //             groupDiv.appendChild(settingDiv);
        //         });
                
        //         flexContainer.appendChild(groupDiv);
        //     });
            
        //     container.appendChild(flexContainer);
        // }

        // ============================================================================
        // UTILITY FUNCTIONS FOR FORMATTING
        // ============================================================================
        
        // Format group names by adding spaces before capital letters and capitalizing first letter
        // Example: "cameraSettings" -> "Camera Settings"
        // function formatGroupName(groupKey) {
        //     return groupKey
        //         .replace(/([A-Z])/g, ' $1') // Add space before capital letters
        //         .replace(/^./, str => str.toUpperCase()) // Capitalize first letter
        //         .trim();
        // }

        // Format individual setting names for display
        // For simple settings: "fps" -> "Fps"
        // For nested settings: "shock_zones.zone1.intensity" -> "Zone1 ‚Üí Intensity"
        // function formatSettingName(setting) {
        //     const parts = setting.split('.');
        //     if (parts.length <= 2) {
        //         return parts[parts.length - 1]
        //             .replace(/([A-Z])/g, ' $1') // Add space before capital letters
        //             .replace(/^./, str => str.toUpperCase()) // Capitalize first letter
        //             .trim();
        //     } else {
        //         // For deeply nested settings, show the last two parts with an arrow
        //         const lastTwo = parts.slice(-2);
        //         return lastTwo.map(part => 
        //             part.replace(/([A-Z])/g, ' $1')
        //                 .replace(/^./, str => str.toUpperCase())
        //                 .trim()
        //         ).join(' ‚Üí ');
        //     }
        // }

        // ============================================================================
        // SETTINGS PARSING AND EXTRACTION
        // ============================================================================
        
        // Recursively extract all settings from a nested object and convert to dot notation
        // This function flattens the nested structure for easier form generation
        // function findSettingsFromObject(obj, parentKey = "", fullParentKey = ""){
        //     for (const key in obj) {
        //         const value = obj[key]; 
        //         if (typeof value === "object" && value !== null && !Array.isArray(value)){
        //             // This is a nested object, so we need to go deeper
        //             const nextFullParentKey = fullParentKey + "." + key;
        //             console.log(nextFullParentKey, " is a group of settings.");
        //             findSettingsFromObject(value, key, nextFullParentKey); // Recursive call
        //         } else {
        //             // This is a leaf value (actual setting)
        //             const setting = fullParentKey.slice(1) + "." + key; // Remove leading dot
        //             console.log(setting, " is a setting of type ", typeof(value));
        //             settingsArray.push(setting); 
                    
        //             // Store the setting's type and value for form generation
        //             if (!parsedSettings[setting]) {
        //                 parsedSettings[setting] = {};
        //             }
        //             parsedSettings[setting]["type"] = typeof(value);
        //             parsedSettings[setting]["value"] = value;
        //         }
        //     }
        // }

        // ============================================================================
        // FORM SUBMISSION HANDLERS
        // ============================================================================
        
        // Handle submission of the main settings form
        // document.getElementById("settings-form").addEventListener('submit', function(e) {
        //     e.preventDefault(); // Prevent default form submission behavior
            
        //     // Collect all form data using FormData API
        //     const formData = new FormData(this);
        //     const settingsData = {};
            
        //     // Convert FormData to a regular JavaScript object
        //     for (let [key, value] of formData.entries()) {
        //         settingsData[key] = value;
        //     }
            
        //     console.log('Sending settings to backend:', settingsData);
            
        //     // Send the settings data to the backend via Socket.IO
        //     socket.emit('save_settings', settingsData);
            
        //     // Show visual feedback to the user that the save was successful
        //     const saveButton = document.getElementById('save-settings-button');
        //     const originalText = saveButton.textContent;
        //     saveButton.textContent = '‚úÖ Saved!';
        //     saveButton.disabled = true;
            
        //     // Reset the button after 2 seconds
        //     setTimeout(() => {
        //         saveButton.textContent = originalText;
        //         saveButton.disabled = false;
        //     }, 2000);
        // });

        // Handle reset button click for the main settings form
        const resetButton = document.getElementById("reset-settings-button");
        if (resetButton) {
            resetButton.addEventListener('click', function() {
                if (confirm('Are you sure you want to reset all changes?')) {
                    socket.emit('reset_settings');
                }
            });
        }

        // ============================================================================
        // MODULE CONFIGURATION MANAGEMENT
        // ============================================================================
        
        // Request module configurations from the backend
        function getModuleConfigs() {
            console.log('Requesting module configurations...');
            socket.emit('get_module_configs');
        }

        // Toggle configuration section dropdown
        function toggleConfigSection(sectionId) {
            const content = document.getElementById(`content-${sectionId}`);
            const arrow = document.getElementById(`arrow-${sectionId}`);
            
            if (content.style.display === 'none' || content.style.display === '') {
                content.style.display = 'block';
                arrow.textContent = '‚ñº';
                arrow.style.transform = 'rotate(0deg)';
            } else {
                content.style.display = 'none';
                arrow.textContent = '‚ñ∂';
                arrow.style.transform = 'rotate(-90deg)';
            }
        }
        
        // Save the current state of open sections
        function saveOpenSections() {
            openSections.clear();
            document.querySelectorAll('.config-section-content').forEach(content => {
                if (content.style.display !== 'none' && content.style.display !== '') {
                    const sectionId = content.id.replace('content-', '');
                    openSections.add(sectionId);
                }
            });
        }
        
        // Restore the state of open sections
        function restoreOpenSections() {
            openSections.forEach(sectionId => {
                const content = document.getElementById(`content-${sectionId}`);
                const arrow = document.getElementById(`arrow-${sectionId}`);
                if (content && arrow) {
                    content.style.display = 'block';
                    arrow.textContent = '‚ñº';
                    arrow.style.transform = 'rotate(0deg)';
                }
            });
        }
        
        // Display module configurations in the UI, focusing on editable sections
        function displayModuleConfigs(moduleConfigs) {
            const container = document.getElementById('module-configs-content');
            
            // Save the current state of open sections before regenerating
            saveOpenSections();
            
            // Handle case where no module configs are available
            if (!moduleConfigs || Object.keys(moduleConfigs).length === 0) {
                container.innerHTML = '<p class="no-configs-message">No module configurations available.</p>';
                return;
            }
            
            let html = '';
            // Iterate through each module's configuration
            Object.entries(moduleConfigs).forEach(([moduleId, config]) => {
                html += `<div class="module-config-item">`;
                html += `<h3>Module: ${moduleId}</h3>`;

                // The config is now the editable section directly (not nested under 'editable')
                if (config && Object.keys(config).length > 0) {
                    html += `<form class="module-config-form" data-module-id="${moduleId}">`;
                    html += generateConfigForm(config, moduleId);
                    html += `</form>`;
                } else {
                    html += `<p class="no-configs-message">No editable configuration available for this module.</p>`;
                }

                html += `</div>`;
            });
            
            container.innerHTML = html;

            // Add event listeners to all module config forms
            document.querySelectorAll('.module-config-form').forEach(form => {
                form.addEventListener('submit', handleFormSubmit);
            });
            
            // Restore the state of open sections after regenerating
            setTimeout(restoreOpenSections, 0);
        }

        // ============================================================================
        // MODULE CONFIG FORM GENERATION
        // ============================================================================
        
        // Recursively generate form fields for module configuration
        // This function handles nested objects by creating sections and leaf values by creating inputs
        function generateConfigForm(config, moduleId, prefix = '') {
            let html = '';
            
            // Iterate through each key-value pair in the config
            Object.entries(config).forEach(([key, value]) => {
                // Create the full key path for nested settings
                const fullKey = prefix ? `${prefix}.${key}` : key;

                if (typeof value === 'object' && !Array.isArray(value)) {
                    // This is a nested object - create a collapsible section
                    const sectionId = `${moduleId}_${fullKey.replace(/\./g, '_')}`;
                    html += `<div class="config-section">`;
                    html += `<div class="config-section-header" onclick="toggleConfigSection('${sectionId}')">`;
                    html += `<h4>${formatLabel(key)}</h4>`;
                    html += `<span class="dropdown-arrow" id="arrow-${sectionId}">‚ñº</span>`;
                    html += `</div>`;
                    html += `<div class="config-section-content" id="content-${sectionId}">`;
                    html += `<div class="compact-form">`;
                    html += generateConfigForm(value, moduleId, fullKey); // Recursive call for nested object
                    html += `</div>`;
                    html += `</div>`;
                    html += `</div>`;
                } else {
                    // This is a leaf value - create an input field
                    html += `<div class="input-group">`;
                    html += createInputField(fullKey, value, moduleId);
                    html += `</div>`;
                }
            });

            return html;
        }

        // Create individual input fields based on the data type
        function createInputField(key, value, moduleId) {
            // Create a unique ID for the input field
            const inputId = `${moduleId}_${key.replace(/\./g, '_')}`;
            
            // Extract the last part of the dot notation and format it nicely
            const displayName = formatParameterName(key);
            
            // Handle boolean values with a dropdown select
            if (typeof value === 'boolean') {
                return `
                    <label for="${inputId}">${displayName}</label>
                    <select id="${inputId}" name="${key}">
                        <option value="true" ${value ? 'selected' : ''}>True</option>
                        <option value="false" ${!value ? 'selected' : ''}>False</option>
                    </select>
                `;
            }
            
            // Handle numeric values with number input
            if (typeof value === 'number') {
                return `
                    <label for="${inputId}">${displayName}</label>
                    <input type="number" id="${inputId}" name="${key}" value="${value}" step="any">
                `;
            }
            
            // Handle array values (like coordinates) with text input
            if (Array.isArray(value)) {
                return `
                    <label for="${inputId}">${displayName}</label>
                    <input type="text" id="${inputId}" name="${key}" value="${JSON.stringify(value)}" 
                   placeholder="[x, y, width, height]">
        `;
            }
            
            // Handle string values with text input
            return `
                <label for="${inputId}">${displayName}</label>
                <input type="text" id="${inputId}" name="${key}" value="${value}">
            `;
        }
    
        // Handle submission of module configuration forms
        function handleFormSubmit(event) {
            event.preventDefault(); // Prevent default form submission
            
            const form = event.target;
            const moduleId = form.dataset.moduleId; // Get the module ID from the form's data attribute
            const formData = new FormData(form);
            const configData = {};
            
            // Convert flat form data to nested object structure
            for (let [key, value] of formData.entries()) {
                setNestedValue(configData, key, value);
            }
            
            // Send the updated configuration to the backend
            // Wrap in 'editable' structure to match the module's config format
            socket.emit('send_command', {
                module_id: moduleId,
                type: "set_config",
                params: { editable: configData }
            });
        }

        // ============================================================================
        // UTILITY FUNCTIONS
        // ============================================================================
        
        // Refresh the livestream by forcing a new connection
        // This is called when the module indicates streaming has started
        function refreshLivestream() {
            const livestreamVideo = document.getElementById('livestream-video');
            if (livestreamVideo && livestreamVideo.src) {
                console.log('Refreshing livestream connection...');
                const currentSrc = livestreamVideo.src.split('?')[0]; // Remove any existing parameters
                livestreamVideo.src = currentSrc + '?t=' + Date.now(); // Add timestamp to force reload
            }
        }
        
        // Format labels by adding spaces before capital letters and capitalizing first letter
        // Example: "shockZones" -> "Shock Zones"
        function formatLabel(key) {
            return key
                .replace(/([A-Z])/g, ' $1')  // Add space before capital letters
                .replace(/^./, str => str.toUpperCase())  // Capitalize first letter
                .replace(/_/g, ' ')  // Replace underscores with spaces
                .trim();
        }

        // Format parameter names by extracting the last part of dot notation and formatting nicely
        // Example: "mask.mask_radius" -> "Mask Radius"
        function formatParameterName(key) {
            // Extract the last part of the dot notation
            const parts = key.split('.');
            const lastPart = parts[parts.length - 1];
            
            // Format the last part using the same logic as formatLabel
            return lastPart
                .replace(/([A-Z])/g, ' $1')  // Add space before capital letters
                .replace(/^./, str => str.toUpperCase())  // Capitalize first letter
                .replace(/_/g, ' ')  // Replace underscores with spaces
                .trim();
        }

        // Convert flat form data (dot notation) to nested object structure
        // This is essential for handling nested configurations like "shock_zones.zone1.intensity"
        function setNestedValue(obj, path, value) {
            // Split the path by dots to get individual keys
            const keys = path.split('.');
            let current = obj;
            
            // Navigate through the object structure, creating nested objects as needed
            for (let i = 0; i < keys.length - 1; i++) {
                const key = keys[i];
                if (!(key in current)) {
                    current[key] = {};
                }
                current = current[key];
            }
            
            // Set the final value at the leaf node
            const lastKey = keys[keys.length - 1];
            
            // Convert the string value to the appropriate data type
            if (value === 'true') {
                current[lastKey] = true;
            } else if (value === 'false') {
                current[lastKey] = false;
            } else if (!isNaN(value) && value !== '') {
                // Convert to number (handles both integers and floats)
                current[lastKey] = Number(value);
            } else if (value.startsWith('[') && value.endsWith(']')) {
                // Try to parse as JSON array (for coordinate arrays)
                try {
                    current[lastKey] = JSON.parse(value);
                } catch {
                    // If parsing fails, keep as string
                    current[lastKey] = value;
                }
            } else {
                // Keep as string for other values
                current[lastKey] = value;
            }
        }

        // Reset configuration for a specific module
        function resetConfig(moduleId) {
            if (confirm(`Are you sure you want to reset the configuration for module ${moduleId}?`)) {
                // Request fresh config from the module
                socket.emit('get_module_configs');
            }
        }

        // Save all module configurations
        function saveAllConfigs() {
            const forms = document.querySelectorAll('.module-config-form');
            if (forms.length === 0) {
                alert('No module configurations to save.');
                return;
            }

            const saveAllBtn = document.getElementById('save-all-configs-btn');
            const originalText = saveAllBtn.textContent;
            saveAllBtn.textContent = 'üíæ Saving...';
            saveAllBtn.disabled = true;

            let savedCount = 0;
            let totalForms = forms.length;

            forms.forEach((form, index) => {
                const moduleId = form.dataset.moduleId;
                const formData = new FormData(form);
                const configData = {};
                
                // Convert flat form data to nested object structure
                for (let [key, value] of formData.entries()) {
                    setNestedValue(configData, key, value);
                }
                
                // Send the updated configuration to the backend
                socket.emit('send_command', {
                    module_id: moduleId,
                    type: "set_config",
                    params: { editable: configData }
                });

                savedCount++;
                
                // If this is the last form, restore the button
                if (savedCount === totalForms) {
                    setTimeout(() => {
                        saveAllBtn.textContent = '‚úÖ Saved!';
                        setTimeout(() => {
                            saveAllBtn.textContent = originalText;
                            saveAllBtn.disabled = false;
                        }, 2000);
                    }, 500);
                }
            });
        }

        // Reset all module configurations
        function resetAllConfigs() {
            if (confirm('Are you sure you want to reset all module configurations? This will discard all unsaved changes.')) {
                const resetAllBtn = document.getElementById('reset-all-configs-btn');
                const originalText = resetAllBtn.textContent;
                resetAllBtn.textContent = 'üîÑ Resetting...';
                resetAllBtn.disabled = true;

                // Request fresh configs from all modules
                socket.emit('get_module_configs');
                
                setTimeout(() => {
                    resetAllBtn.textContent = '‚úÖ Reset!';
                    setTimeout(() => {
                        resetAllBtn.textContent = originalText;
                        resetAllBtn.disabled = false;
                    }, 2000);
                }, 1000);
            }
        }

        // Add event listeners for the new action buttons
        document.addEventListener('DOMContentLoaded', function() {
            const saveAllBtn = document.getElementById('save-all-configs-btn');
            const resetAllBtn = document.getElementById('reset-all-configs-btn');
            
            if (saveAllBtn) {
                saveAllBtn.addEventListener('click', saveAllConfigs);
            }
            
            if (resetAllBtn) {
                resetAllBtn.addEventListener('click', resetAllConfigs);
            }
        });

        // Call once on page load
        getModuleConfigs();
    </script>
</body>
</html>